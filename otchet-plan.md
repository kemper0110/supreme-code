## Главные фичи (чтобы не забыть)
- онлайн-компилятор со стримингом логов
- версионирование задач
- совместное редактирование кода

## Название темы (чтобы тоже не забыть)
Онлайн-платформа с алгоритмическими задачами по программированию

## Сделать

- ПОЗЖЕ: Титульники
- Лист задания
- уточнить даты в ТЗ

## Общий план

- [x] Написать введение
- [x] Аналитический обзор
  - [x] Описание
  - [x] Автоматизированная проверка
  - [x] Запуск в докере
  - [x] Обзор существующих решений
    - Codewars
    - LeetCode
    - Информатикс
  - [x] Постановка задачи
  - [x] Вывод по главе
- [x] Проектирование платформы
  - [x] Проектирование структуры данных
    - [x] Задача (включая файлы с решением и тестами)
    - [x] Решение
    - [x] Результат проверки решения
    - [x] Пользователь
  - [x] Проектирование базы данных
  - [x] Проектирование микросервисной архитектуры
    - [x] Веб-сервер
    - [x] Test-runner
    - [x] Task-runner
  - [x] Проектирование алгоритмов
    - [x] Алгоритм проверки решения диаграмма последовательности
    - [x] Алгоритм прерывания выполнения кода в контейнере блок-схемой
- [x] Программное конструирование
  - [x] Обоснование выбора средств разработки
  - [x] Описание модульной структуры программного средства
    - [x] Классы веб-сервера, все это в виде UML
      - [x] состоит из 4-х модулей. их описание. рассмотрим самые интересные классы этих модулей
      - [x] Работа с пользователем ProblemController, ProblemService, SolutionResultRepository, SolutionRepository
      - [x] Работа с сервисом тестирования TestResultAnalyzerService, TestRunnerChannelService, TestRunnerSenderService
      - [x] Модуль статистики StatisticService, StatisticRepository, StatisticController
      - [x] Модуль работы с пользователями UserService, UserRepository, UserController
    - [x] Классы Test-runner
      - CppTester, JavaTester, JavaScriptTester, Listener, Tester
      - Диаграмма и описание че делают
    - [x] Классы Task-runner
      - Events, Runner, ...
      - Диаграмма и описание че делают
  - [x] Описание модели хранения задач
    - [x] Схема валидации данных
- [x] Тестирование работы программы


## Презентация

> Основная часть выступления должна быть посвящена тому, что сделали вы лично в ходе
> выполнения ВКР.
> от 5 до 7 минут

### Что же я сделал лично?
Казалось бы дохера, но нужно перечислить, что я сделал.

- Рассказать зачем нужны онлайн-платформы с алгоритмическими задачами по программированию
- Продемонстрировать работу supreme-code
  - Выбрали задачу
  - Прочитали описание
  - Напрограммировали решение
  - Отправили на проверку
  - Дождались результатов автоматизированного тестирования
  - На этом демонстрация платформы завершена
- Модуль задач
  - Посмотрим какая последовательность работ приводит к такому результату
    1. получение запроса на тестирование
    2. положить решение в БД и в очередь для тестирования
       - БД для хранения решений и результатов
       - Apache Kafka может быть использована как точка горизонтального масштабирования
       - Также использование Kafka позволяет избежать потери сообщений и их дублирования
    3. получить из очереди решение для тестирования
       - Если будет запущена группа тест-раннеров, то сообщение не будут дублироваться между ними,
       каждый получит свою работу
    4. создается контейнера для тестирования
       - построено 3 кастомных docker-образа: c++, java, javascript
         - каждый образ содержит среду выполнения для своего языка (из базового образа)
         - каждый образ содержит все необходимые библиотеки для выполнения тестирования
         - каждый образ при запуске оказывается полностью изолирован от машины на которой запускается docker
         - я попытался все собранные образы максимально ограничить
           - он не имеет доступа к сети
           - нет подключенных волюмов, и открытых портов
           - используется несистемный пользователь
           - запрещено применение новых привелегий
           - выставлены ограничения по памяти, процессору и свопу, по количеству открытых дескрипторов 
           - работа с данными контейнера осуществляется только, когда он остановлен
       - каждый тест-раннер общается со своим docker engine по rest api
       - скрин из [документации](https://docs.docker.com/engine/api/v1.45/#tag/Container/operation/ContainerExport)
       - в контейнер копируется tar-архив директорией задачи и файлом решения
    5. запустить контейнер
       - совместно с ним запускаются процессы по чтению логов от контейнера, ожидания завершения 
         и ожидания таймаута (для контейнеров установлено ограничение на время работы)
    6. дождались пока контейнер потухнет
    7. только после кончины контейнера идем скачивать junit.xml из него
    8. после этого благополучно удаляем контейнер
    9. собрать основные данные из junit.xml
       - тестовые фреймворки производят различный вывод
       - я искал универсальный формат вывода
       - оказалось, что формат предлагаемый тестовым фреймворком Junit для Java - junit.xml 
         является стандартом в мире отчетов о тестировании
       - для Java потребовалось surefire-plugin, для JavaScript - jest-plugin, а для C++ - кроме библиотеки
         тестирования googletest - ниче не понадобилось - все есть из коробки
    10. вернуть обратно в очередь данные из junit.xml
    11. в очереди поджидает вебсервер, чтобы проанализировать результаты тестирования
        - анализ сводится к проверке, что все тесты проходят
        - проверок по времени выполнения, занимаемой памяти, процессорной нагрузки - нет
    12. положить в БД результаты тестирования
        - показать второй кусок схемы БД с результатами тестирования
    13. вернуть пользователю результаты тестирования
        - все это время с пользователем поддерживается открытое соединение, чтобы 
          оперативно вернуть результаты тестирования
- Модуль статистики
  - Десяток нативных sql-запросов к Postgres
  - Вывод результатов в виде графиков на фронтенде
- Модуль test-runner
  - Удобная площадка для экспериментов: быстро проверить работоспособность кода, эксперименты частями кода и языковыми конструкциями
    - такая площадка есть только в leetcode
  - Фича со стримингом логов: более быстрая отладка кода. можно запускать код и анализировать результаты на лету.
    - такого не видел даже на leetcode
- Совместное редактирование на фронте
  - Такой фичи нет даже на leetcode
  - Я использовал библиотеку для совместной работы с документами
  - Реализация независима от используемого протокола, 
    есть возможность использовать webrtc для непосредственного соединения участников (схемку),
    но я применил websocket как более простой для отладки и более надежный при установке соединения
- сравнение площадок закинуть в самый конец